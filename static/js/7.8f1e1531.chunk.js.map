{"version":3,"sources":["../../lib/utils.js","../../lib/image-compression.js","../../lib/web-worker.js","../../lib/index.js","component/Compression.js","component/Algorithms/compression/PNG_JPG_Compressor.js","component/Algorithms/compression/WEBPCompressor.js","component/Algorithms/compression/PDFCompressor.js"],"names":["window","CustomFile","reader","reject","file","getFilefromDataUrl","s","n","loadImage","view","result","length","offset","o","marker","width","height","canvas","options","ctx","maxWidthOrHeight","followExifOrientation","lastModified","c","cnt","compressOnWebWorker","imageCompression","name","Compression","useState","setFile","success","setSuccess","load","setLoading","from","type","setType","className","onChange","e","target","value","defaultValue","style","color","accept","files","max","onClick","preventDefault","size","alert","toLowerCase","split","pop","si","maxSizeMB","useWebWorker","then","compressedFile","blob","FileReader","readAsDataURL","onloadend","dataURI","document","getElementById","innerText","toFixed","download","href","catch","error","console","log","message","PNG_JPG_Compressor","onload","dataURL","getContext","image","Image","innerWidth","innerHeight","drawImage","src","setTimeout","toDataURL","replace","imgFileSize","Math","round","WEBPCompressor","readAsArrayBuffer","PDFCompressor","id","display","setSucess","byteString","atob","mimeString","arrayBuffer","ArrayBuffer","_ia","Uint8Array","i","charCodeAt","dataView","DataView","Blob","URL","createObjectURL","downloadWEBP","doc","jsPDF","addImage","undefined","save","downloadPDF"],"mappings":"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","file":"static/js/7.8f1e1531.chunk.js","sourcesContent":["// add support for cordova-plugin-file\nconst moduleMapper = typeof window !== 'undefined' && window.cordova && window.cordova.require('cordova/modulemapper');\nexport const CustomFile = (moduleMapper && moduleMapper.getOriginalSymbol(window, 'File')) || File;\nexport const CustomFileReader = (moduleMapper && moduleMapper.getOriginalSymbol(window, 'FileReader')) || FileReader;\n/**\n * getDataUrlFromFile\n *\n * @param {File} file\n * @returns {Promise<string>}\n */\nexport function getDataUrlFromFile (file) {\n  return new Promise((resolve, reject) => {\n    const reader = new CustomFileReader()\n    reader.onload = () => resolve(reader.result)\n    reader.onerror = (e) => reject(e)\n    reader.readAsDataURL(file)\n  })\n}\n\n/**\n * getFilefromDataUrl\n *\n * @param {string} dataurl\n * @param {string} filename\n * @param {number} [lastModified=Date.now()]\n * @returns {Promise<File|Blob>}\n */\nexport function getFilefromDataUrl (dataurl, filename, lastModified = Date.now()) {\n  return new Promise((resolve) => {\n    const arr = dataurl.split(',')\n    const mime = arr[0].match(/:(.*?);/)[1]\n    const bstr = atob(arr[1])\n    let n = bstr.length\n    const u8arr = new Uint8Array(n)\n    while (n--) {\n      u8arr[n] = bstr.charCodeAt(n)\n    }\n    const file = new Blob([u8arr], { type: mime })\n    file.name = filename\n    file.lastModified = lastModified\n    resolve(file)\n\n    // Safari has issue with File constructor not being able to POST in FormData\n    // https://github.com/Donaldcwl/browser-image-compression/issues/8\n    // https://bugs.webkit.org/show_bug.cgi?id=165081\n    // let file\n    // try {\n    //   file = new File([u8arr], filename, { type: mime }) // Edge do not support File constructor\n    // } catch (e) {\n    //   file = new Blob([u8arr], { type: mime })\n    //   file.name = filename\n    //   file.lastModified = lastModified\n    // }\n    // resolve(file)\n  })\n}\n\n/**\n * loadImage\n *\n * @param {string} src\n * @returns {Promise<HTMLImageElement>}\n */\nexport function loadImage (src) {\n  return new Promise((resolve, reject) => {\n    const img = new Image()\n    img.onload = () => resolve(img)\n    img.onerror = (e) => reject(e)\n    img.src = src\n  })\n}\n\n/**\n * drawImageInCanvas\n *\n * @param {HTMLImageElement} img\n * @returns {HTMLCanvasElement}\n */\nexport function drawImageInCanvas (img) {\n  const [canvas, ctx] = getNewCanvasAndCtx(img.width, img.height)\n  ctx.drawImage(img, 0, 0, canvas.width, canvas.height)\n  return canvas\n}\n\n/**\n * drawFileInCanvas\n *\n * @param {File} file\n * @returns {Promise<[ImageBitmap | HTMLImageElement, HTMLCanvasElement]>}\n */\nexport async function drawFileInCanvas (file) {\n  let img\n  try {\n    img = await createImageBitmap(file)\n  } catch (e) {\n    const dataUrl = await getDataUrlFromFile(file)\n    img = await loadImage(dataUrl)\n  }\n  const canvas = drawImageInCanvas(img)\n  return [img, canvas]\n}\n\n/**\n * canvasToFile\n *\n * @param canvas\n * @param {string} fileType\n * @param {string} fileName\n * @param {number} fileLastModified\n * @param {number} [quality]\n * @returns {Promise<File|Blob>}\n */\nexport async function canvasToFile (canvas, fileType, fileName, fileLastModified, quality = 1) {\n  let file\n  if (typeof OffscreenCanvas === 'function' && canvas instanceof OffscreenCanvas) {\n    file = await canvas.convertToBlob({ type: fileType, quality })\n    file.name = fileName\n    file.lastModified = fileLastModified\n  } else {\n    const dataUrl = canvas.toDataURL(fileType, quality)\n    file = await getFilefromDataUrl(dataUrl, fileName, fileLastModified)\n  }\n  return file\n}\n\n/**\n * getExifOrientation\n * get image exif orientation info\n * source: https://stackoverflow.com/a/32490603/10395024\n *\n * @param {File} file\n * @returns {Promise<number>} - orientation id, see https://i.stack.imgur.com/VGsAj.gif\n */\nexport function getExifOrientation (file) {\n  return new Promise((resolve, reject) => {\n    const reader = new CustomFileReader()\n    reader.onload = (e) => {\n      const view = new DataView(e.target.result)\n      if (view.getUint16(0, false) != 0xFFD8) {\n        return resolve(-2)\n      }\n      const length = view.byteLength\n      let offset = 2\n      while (offset < length) {\n        if (view.getUint16(offset + 2, false) <= 8) return resolve(-1)\n        const marker = view.getUint16(offset, false)\n        offset += 2\n        if (marker == 0xFFE1) {\n          if (view.getUint32(offset += 2, false) != 0x45786966) {\n            return resolve(-1)\n          }\n\n          var little = view.getUint16(offset += 6, false) == 0x4949\n          offset += view.getUint32(offset + 4, little)\n          var tags = view.getUint16(offset, little)\n          offset += 2\n          for (var i = 0; i < tags; i++) {\n            if (view.getUint16(offset + (i * 12), little) == 0x0112) {\n              return resolve(view.getUint16(offset + (i * 12) + 8, little))\n            }\n          }\n        } else if ((marker & 0xFF00) != 0xFF00) {\n          break\n        } else {\n          offset += view.getUint16(offset, false)\n        }\n      }\n      return resolve(-1)\n    }\n    reader.onerror = (e) => reject(e)\n    reader.readAsArrayBuffer(file)\n  })\n}\n\n/**\n *\n * @param {HTMLCanvasElement} canvas\n * @param options\n * @returns {HTMLCanvasElement>}\n */\nexport function handleMaxWidthOrHeight (canvas, options) {\n  const width = canvas.width\n  const height = canvas.height\n  const maxWidthOrHeight = options.maxWidthOrHeight\n\n  const needToHandle = Number.isInteger(maxWidthOrHeight) && (width > maxWidthOrHeight || height > maxWidthOrHeight)\n\n  let newCanvas = canvas\n  let ctx\n\n  if (needToHandle) {\n    [newCanvas, ctx] = getNewCanvasAndCtx(width, height)\n    if (width > height) {\n      newCanvas.width = maxWidthOrHeight\n      newCanvas.height = (height / width) * maxWidthOrHeight\n    } else {\n      newCanvas.width = (width / height) * maxWidthOrHeight\n      newCanvas.height = maxWidthOrHeight\n    }\n    ctx.drawImage(canvas, 0, 0, newCanvas.width, newCanvas.height)\n  }\n\n  return newCanvas\n}\n\n/**\n * followExifOrientation\n * source: https://stackoverflow.com/a/40867559/10395024\n *\n * @param {HTMLCanvasElement} canvas\n * @param {number} exifOrientation\n * @returns {HTMLCanvasElement} canvas\n */\nexport function followExifOrientation (canvas, exifOrientation) {\n  const width = canvas.width\n  const height = canvas.height\n\n  const [newCanvas, ctx] = getNewCanvasAndCtx(width, height)\n\n  // set proper canvas dimensions before transform & export\n  if (4 < exifOrientation && exifOrientation < 9) {\n    newCanvas.width = height\n    newCanvas.height = width\n  } else {\n    newCanvas.width = width\n    newCanvas.height = height\n  }\n\n  // transform context before drawing image\n  switch (exifOrientation) {\n    case 2: ctx.transform(-1, 0, 0, 1, width, 0); break;\n    case 3: ctx.transform(-1, 0, 0, -1, width, height); break;\n    case 4: ctx.transform(1, 0, 0, -1, 0, height); break;\n    case 5: ctx.transform(0, 1, 1, 0, 0, 0); break;\n    case 6: ctx.transform(0, 1, -1, 0, height, 0); break;\n    case 7: ctx.transform(0, -1, -1, 0, height, width); break;\n    case 8: ctx.transform(0, -1, 1, 0, 0, width); break;\n    default: break;\n  }\n\n  ctx.drawImage(canvas, 0, 0, width, height)\n\n  return newCanvas\n}\n\n/**\n * get new Canvas and it's context\n * @param width\n * @param height\n * @returns {[HTMLCanvasElement, CanvasRenderingContext2D]}\n */\nexport function getNewCanvasAndCtx (width, height) {\n  let canvas\n  let ctx\n  try {\n    canvas = new OffscreenCanvas(width, height)\n    ctx = canvas.getContext('2d')\n  } catch (e) {\n    canvas = document.createElement('canvas')\n    ctx = canvas.getContext('2d')\n  }\n  canvas.width = width\n  canvas.height = height\n  return [canvas, ctx]\n}","import { canvasToFile, drawFileInCanvas, followExifOrientation, getExifOrientation, handleMaxWidthOrHeight, getNewCanvasAndCtx } from './utils'\n\n/**\n * Compress an image file.\n *\n * @param {File} file\n * @param {Object} options - { maxSizeMB=Number.POSITIVE_INFINITY, maxWidthOrHeight, useWebWorker=true, maxIteration = 10, exifOrientation }\n * @param {number} [options.maxSizeMB=Number.POSITIVE_INFINITY]\n * @param {number} [options.maxWidthOrHeight=undefined] * @param {number} [options.maxWidthOrHeight=undefined]\n * @param {number} [options.maxIteration=10]\n * @param {number} [options.exifOrientation=] - default to be the exif orientation from the image file\n * @returns {Promise<File | Blob>}\n */\nexport default async function compress (file, options) {\n  let remainingTrials = options.maxIteration || 10\n\n  const maxSizeByte = options.maxSizeMB * 1024 * 1024\n\n  // drawFileInCanvas\n  let [img, canvas] = await drawFileInCanvas(file)\n\n  // handleMaxWidthOrHeight\n  canvas = handleMaxWidthOrHeight(canvas, options)\n\n  // exifOrientation\n  options.exifOrientation = options.exifOrientation || await getExifOrientation(file)\n  canvas = followExifOrientation(canvas, options.exifOrientation)\n\n  let quality = 1\n\n  let tempFile = await canvasToFile(canvas, file.type, file.name, file.lastModified, quality)\n  // check if we need to compress or resize\n  if (tempFile.size <= maxSizeByte) {\n    // no need to compress\n    return tempFile\n  }\n\n  let compressedFile = tempFile\n  while (remainingTrials-- && compressedFile.size > maxSizeByte) {\n    const newWidth = canvas.width * 0.9\n    const newHeight = canvas.height * 0.9\n    const [newCanvas, ctx] = getNewCanvasAndCtx(newWidth, newHeight)\n\n    ctx.drawImage(canvas, 0, 0, newWidth, newHeight)\n\n    if (file.type === 'image/jpeg') {\n      quality *= 0.9\n    }\n    compressedFile = await canvasToFile(newCanvas, file.type, file.name, file.lastModified, quality)\n\n    canvas = newCanvas\n  }\n\n  return compressedFile\n}","import imageCompression from './index'\nimport compress from './image-compression'\nimport { getNewCanvasAndCtx } from './utils'\n\nlet cnt = 0\nlet imageCompressionLibUrl\n\nfunction createWorker (f) {\n  return new Worker(URL.createObjectURL(new Blob([`(${f})()`])))\n}\n\nconst worker = createWorker(() => {\n  let scriptImported = false\n  self.addEventListener('message', async (e) => {\n    const { file, id, imageCompressionLibUrl, options } = e.data\n    try {\n      if (!scriptImported) {\n        // console.log('[worker] importScripts', imageCompressionLibUrl)\n        importScripts(imageCompressionLibUrl)\n        scriptImported = true\n      }\n      // console.log('[worker] self', self)\n      const compressedFile = await imageCompression(file, options)\n      self.postMessage({ file: compressedFile, id })\n    } catch (e) {\n      // console.error('[worker] error', e)\n      self.postMessage({ error: e.message + '\\n' + e.stack, id })\n    }\n  })\n})\n\nfunction createSourceObject (str) {\n  return URL.createObjectURL(new Blob([str], { type: 'application/javascript' }))\n}\n\nexport function compressOnWebWorker (file, options) {\n  return new Promise(async (resolve, reject) => {\n    if (!imageCompressionLibUrl) {\n      imageCompressionLibUrl = createSourceObject(`\n    function imageCompression (){return (${imageCompression}).apply(null, arguments)}\n\n    imageCompression.getDataUrlFromFile = ${imageCompression.getDataUrlFromFile}\n    imageCompression.getFilefromDataUrl = ${imageCompression.getFilefromDataUrl}\n    imageCompression.loadImage = ${imageCompression.loadImage}\n    imageCompression.drawImageInCanvas = ${imageCompression.drawImageInCanvas}\n    imageCompression.drawFileInCanvas = ${imageCompression.drawFileInCanvas}\n    imageCompression.canvasToFile = ${imageCompression.canvasToFile}\n    imageCompression.getExifOrientation = ${imageCompression.getExifOrientation}\n    imageCompression.handleMaxWidthOrHeight = ${imageCompression.handleMaxWidthOrHeight}\n    imageCompression.followExifOrientation = ${imageCompression.followExifOrientation}\n\n    getDataUrlFromFile = imageCompression.getDataUrlFromFile\n    getFilefromDataUrl = imageCompression.getFilefromDataUrl\n    loadImage = imageCompression.loadImage\n    drawImageInCanvas = imageCompression.drawImageInCanvas\n    drawFileInCanvas = imageCompression.drawFileInCanvas\n    canvasToFile = imageCompression.canvasToFile\n    getExifOrientation = imageCompression.getExifOrientation\n    handleMaxWidthOrHeight = imageCompression.handleMaxWidthOrHeight\n    followExifOrientation = imageCompression.followExifOrientation\n\n    getNewCanvasAndCtx = ${getNewCanvasAndCtx}\n    \n    CustomFileReader = FileReader\n    \n    CustomFile = File\n    \n    function _slicedToArray(arr, n) { return arr }\n\n    function compress (){return (${compress}).apply(null, arguments)}\n    `)\n    }\n    let id = cnt++\n\n    function handler (e) {\n      if (e.data.id === id) {\n        worker.removeEventListener('message', handler)\n        if (e.data.error) {\n          reject(new Error(e.data.error))\n        }\n        resolve(e.data.file)\n      }\n    }\n\n    worker.addEventListener('message', handler)\n    worker.postMessage({ file, id, imageCompressionLibUrl, options })\n  })\n}","import compress from './image-compression'\nimport {\n  canvasToFile,\n  drawFileInCanvas,\n  drawImageInCanvas,\n  getDataUrlFromFile,\n  getFilefromDataUrl,\n  loadImage,\n  getExifOrientation,\n  handleMaxWidthOrHeight,\n  followExifOrientation,\n  CustomFile\n} from './utils'\nimport { compressOnWebWorker } from './web-worker'\n\n/**\n * Compress an image file.\n *\n * @param {File} file\n * @param {Object} options - { maxSizeMB=Number.POSITIVE_INFINITY, maxWidthOrHeight, useWebWorker=true, maxIteration = 10, exifOrientation }\n * @param {number} [options.maxSizeMB=Number.POSITIVE_INFINITY]\n * @param {number} [options.maxWidthOrHeight=undefined] * @param {number} [options.maxWidthOrHeight=undefined]\n * @param {boolean} [options.useWebWorker=true]\n * @param {number} [options.maxIteration=10]\n * @param {number} [options.exifOrientation=] - default to be the exif orientation from the image file\n * @returns {Promise<File | Blob>}\n */\nasync function imageCompression (file, options) {\n\n  let compressedFile\n\n  options.maxSizeMB = options.maxSizeMB || Number.POSITIVE_INFINITY\n  options.useWebWorker = typeof options.useWebWorker === 'boolean' ? options.useWebWorker : true\n\n  if (!(file instanceof Blob || file instanceof CustomFile)) {\n    throw new Error('The file given is not an instance of Blob or File')\n  } else if (!/^image/.test(file.type)) {\n    throw new Error('The file given is not an image')\n  }\n\n  // try run in web worker, fall back to run in main thread\n  const inWebWorker = typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope\n\n  // if (inWebWorker) {\n  //   console.log('run compression in web worker')\n  // } else {\n  //   console.log('run compression in main thread')\n  // }\n\n  if (options.useWebWorker && typeof Worker === 'function' && !inWebWorker) {\n    try {\n      // \"compressOnWebWorker\" is kind of like a recursion to call \"imageCompression\" again inside web worker\n      compressedFile = await compressOnWebWorker(file, options)\n    } catch (e) {\n      console.warn('Run compression in web worker failed:', e, ', fall back to main thread')\n      compressedFile = await compress(file, options)\n    }\n  } else {\n    compressedFile = await compress(file, options)\n  }\n\n  try {\n    compressedFile.name = file.name\n    compressedFile.lastModified = file.lastModified\n  } catch (e) {}\n\n  return compressedFile\n}\n\nimageCompression.getDataUrlFromFile = getDataUrlFromFile\nimageCompression.getFilefromDataUrl = getFilefromDataUrl\nimageCompression.loadImage = loadImage\nimageCompression.drawImageInCanvas = drawImageInCanvas\nimageCompression.drawFileInCanvas = drawFileInCanvas\nimageCompression.canvasToFile = canvasToFile\nimageCompression.getExifOrientation = getExifOrientation\nimageCompression.handleMaxWidthOrHeight = handleMaxWidthOrHeight\nimageCompression.followExifOrientation = followExifOrientation\n\nexport default imageCompression\n","import React, { useState } from \"react\";\n// import { JPGCompressor, downloadJPG } from \"./Algorithms/JPGCompressor\";\n// import { PNGCompressor, downloadPNG } from \"./Algorithms/PNGCompressor\";\nimport {\n  downloadWEBP,\n  WEBPCompressor\n} from \"./Algorithms/compression/WEBPCompressor\";\nimport {\n  PDFCompressor,\n  downloadPDF\n} from \"./Algorithms/compression/PDFCompressor\";\nimport { PNG_JPG_Compressor } from \"./Algorithms/compression/PNG_JPG_Compressor\";\nconst Compression = () => {\n  const [file, setFile] = useState(null);\n  const [success, setSuccess] = useState(false);\n  const [load, setLoading] = useState(false);\n  const [type, setType] = useState({\n    from: \"\"\n  });\n  const showName = e => {\n    setFile(e.target.files[0]);\n  };\n  const fileType = e => {\n    //console.log(e.target.value);\n    setType({\n      ...type,\n      [e.target.name]: e.target.value\n    });\n  };\n  const submit = e => {\n    e.preventDefault();\n    if (file === null) {\n      alert(\"Please first select file and types\");\n      return;\n    }\n    if (file.size > 112582912) {\n      alert(\"File Size must be less then 11mb.\");\n      return;\n    }\n    if (type.from === \"\" || type.from === \"Original File Types\") {\n      alert(\"'From' file type is not selected!\");\n      return;\n    }\n    if (type.from.toLowerCase() !== file.name.split(\".\").pop()) {\n      if (type.from === \"JPEG/JPG\") {\n        if (\n          file.name.split(\".\").pop() !== \"jpg\" &&\n          file.name.split(\".\").pop() !== \"jpeg\"\n        ) {\n          alert(\n            \"Mismatch in selected file type: \" +\n              file.name.split(\".\").pop() +\n              \" with 'From' Select box: \" +\n              type.from.toLowerCase()\n          );\n          return false;\n        }\n      } else {\n        alert(\n          \"Mismatch in selected file type: \" +\n            file.name.split(\".\").pop() +\n            \" with 'From' Select box: \" +\n            type.from.toLowerCase()\n        );\n        return false;\n      }\n    }\n    setSuccess(false);\n    setLoading(true);\n    // if (type.from === \"JPG\" || type.from === \"JPEG\") {\n    //   let reader = new FileReader();\n    //   reader.readAsDataURL(file);\n    //   reader.onload = function() {\n    //     const dataURL = reader.result;\n    //     JPGCompressor(dataURL);\n    //   };\n    // }\n    if (\n      type.from === \"JPEG/JPG\" ||\n      type.from === \"PNG\" ||\n      type.from === \"ICO\"\n    ) {\n      PNG_JPG_Compressor(file, setLoading, setSuccess);\n    }\n    if (type.from === \"WEBP\") {\n      let reader = new FileReader();\n      reader.readAsDataURL(file);\n      reader.onload = function() {\n        const dataURL = reader.result;\n        WEBPCompressor(dataURL);\n      };\n    }\n    if (type.from === \"PDF\") {\n      let reader = new FileReader();\n      reader.readAsArrayBuffer(file);\n      reader.onload = function() {\n        const dataURL = reader.result;\n        PDFCompressor(dataURL);\n      };\n    }\n  };\n  //handle download accordingly\n  const download = () => {\n    if (type.from === \"WEBP\") {\n      downloadWEBP(file.name.split(\".\")[0], setSuccess); //passing file name\n    }\n    if (type.from === \"PDF\") {\n      downloadPDF(file.name.split(\".\")[0], setSuccess); //passing file name\n    }\n  };\n  return (\n    <section className=\"container\">\n      <div className=\"level is-mobile\">\n        <div className=\"level-item has-text-centered\">\n          <div className=\"field\">\n            <div className=\"control has-icons-left\">\n              <div className=\"select is-rounded\">\n                <select name=\"from\" onChange={fileType}>\n                  <option defaultValue>Original File Types</option>\n                  <option>PDF</option>\n                  <option>PNG</option>\n                  <option>JPEG/JPG</option>\n                  <option>WEBP</option>\n                  <option>ICO</option>\n                </select>\n              </div>\n              <div className=\"icon is-small is-left\">\n                <i className=\"fas fa-globe\"></i>\n              </div>\n            </div>\n          </div>\n        </div>\n      </div>\n      <p style={{ color: \"red\" }}>\n        *All Compression algo working except pdf compression*\n      </p>\n      <div className=\"level is-mobile\">\n        <div className=\"level-item has-text-centered\">\n          <div className=\"file is-dark has-name is-boxed\">\n            <label className=\"file-label\">\n              <input\n                className=\"file-input\"\n                type=\"file\"\n                name=\"image\"\n                accept=\"image/*\"\n                onChange={showName}\n              />\n              <span className=\"file-cta\">\n                <span className=\"file-icon\">\n                  <i className=\"fas fa-upload\"></i>\n                </span>\n                <span className=\"file-label\">Choose a fileâ€¦</span>\n              </span>\n              <span className=\"file-name\">\n                {file === null ? null : file.name}\n              </span>\n            </label>\n          </div>\n        </div>\n      </div>\n\n      <div className=\"level has-centered\">\n        {load ? (\n          <div className=\"columns level-item has-centered\">\n            <div className=\"column is-two-thirds\">\n              <progress className=\"progress is-dark\" max=\"100\">\n                30%\n              </progress>\n            </div>\n          </div>\n        ) : (\n          <div className=\"level-item has-centered\">\n            <button className=\"button is-dark is-rounded\" onClick={submit}>\n              <span className=\"icon\">\n                <i className=\"fas fa-dice-d20\"></i>\n              </span>\n              <span>Convert</span>\n            </button>\n          </div>\n        )}\n      </div>\n      <canvas\n        className=\"container has-centered\"\n        id=\"jpgtopng\"\n        style={{ display: \"none\" }}\n      ></canvas>\n      <div className=\"has-centered\">\n        {success ? (\n          <div className=\"has-centered\">\n            <div className=\"container level-item has-centered\">\n              <p>Your converted file is ready to download!</p>\n            </div>\n            <div className=\"container level-item has-centered\">\n              <p id=\"size\"></p>\n            </div>\n            <br />\n            <div className=\"container level-item has-centered\">\n              <a\n                onClick={download}\n                id=\"downloader\"\n                href=\"#i\"\n                className=\"button is-dark is-outlined\"\n              >\n                <span className=\"icon is-small\">\n                  <i className=\"fas fa-download\"></i>\n                </span>\n              </a>\n            </div>\n          </div>\n        ) : null}\n      </div>\n      <hr />\n    </section>\n  );\n};\n\nexport default Compression;\n","import imageCompression from \"browser-image-compression\";\nexport const PNG_JPG_Compressor = (file, setLoading, setSuccess) => {\n  let si = 1;\n  if (700 > file.size / 1024) {\n    si = 0.5;\n  }\n  if (10 > file.size / 1024) {\n    si = 0.01;\n  } else {\n    si = 1;\n  }\n  var options = {\n    maxSizeMB: si,\n    maxWidthOrHeight: 1920,\n    useWebWorker: true\n  };\n\n  imageCompression(file, options)\n    .then(function(compressedFile) {\n      let blob = compressedFile;\n      let reader = new FileReader();\n      reader.readAsDataURL(blob);\n      reader.onloadend = () => {\n        let dataURI = reader.result;\n        setLoading(false);\n        setSuccess(true);\n        document.getElementById(\"size\").innerText =\n          \"File Size: \" + (compressedFile.size / 1024).toFixed(2) + \"kb\";\n        document.getElementById(\"downloader\").download = file.name;\n        document.getElementById(\"downloader\").href = dataURI;\n      };\n    })\n    .catch(function(error) {\n      console.log(error.message);\n    });\n};\n","/**\n * Algorithm for JPG Compressor\n */\nexport const WEBPCompressor = dataURL => {\n  var canvas = document.getElementById(\"jpgtopng\");\n  var ctx = canvas.getContext(\"2d\");\n  var image = new Image();\n  ctx.canvas.width = window.innerWidth;\n  ctx.canvas.height = window.innerHeight;\n  image.onload = function() {\n    ctx.drawImage(image, 0, 0, window.innerWidth, window.innerHeight);\n  };\n  image.src = dataURL;\n  setTimeout(() => {\n    let dataURI = document\n      .getElementById(\"jpgtopng\")\n      .toDataURL(\"image/webp\", 0.03)\n      .replace(/^data:image\\/[^;]/, \"data:application/octet-stream\");\n    var head = \"data:image/webp;base64,\";\n    var imgFileSize =\n      Math.round(((dataURI.length - head.length) * 3) / 4) / 1024;\n    document.getElementById(\"size\").innerText =\n      \"File Size: \" + imgFileSize.toFixed(2) + \"kb\";\n  }, 3000);\n};\nexport const downloadWEBP = (name, setSucess) => {\n  //file name as argument\n  document.getElementById(\"downloader\").download = name + \".webp\";\n  // converting data uri to blob aken form github gist\n  let dataURI = document\n    .getElementById(\"jpgtopng\")\n    .toDataURL(\"image/webp\", 0.7)\n    .replace(/^data:image\\/[^;]/, \"data:application/octet-stream\");\n  let byteString = atob(dataURI.split(\",\")[1]);\n\n  // separate out the mime component\n  let mimeString = dataURI\n    .split(\",\")[0]\n    .split(\":\")[1]\n    .split(\";\")[0];\n\n  // write the bytes of the string to an ArrayBuffer\n  let arrayBuffer = new ArrayBuffer(byteString.length);\n  let _ia = new Uint8Array(arrayBuffer);\n  for (let i = 0; i < byteString.length; i++) {\n    _ia[i] = byteString.charCodeAt(i);\n  }\n\n  let dataView = new DataView(arrayBuffer);\n  let blob = new Blob([dataView], { type: mimeString });\n\n  document.getElementById(\"downloader\").href = URL.createObjectURL(blob);\n  setSucess(false);\n};\n","/**\n * Algorithm for PDF Compressor\n */\nimport jsPDF from \"jspdf\";\n\nexport const PDFCompressor = dataURL => {\n  console.log(dataURL);\n  var canvas = document.getElementById(\"jpgtopng\");\n  var ctx = canvas.getContext(\"2d\");\n  var image = new Image();\n  ctx.canvas.width = window.innerWidth;\n  ctx.canvas.height = window.innerHeight;\n  image.onload = function() {\n    ctx.drawImage(image, 0, 0, window.innerWidth, window.innerHeight);\n  };\n  image.src = dataURL;\n};\nexport const downloadPDF = name => {\n  //file name as argument\n  document.getElementById(\"downloader\").download = name + \".pdf\";\n  // converting data uri to blob aken form github gist\n  let dataURI = document\n    .getElementById(\"jpgtopng\")\n    .toDataURL(\"image/jpeg\", 0.3);\n  var doc = new jsPDF(\"p\", \"mm\", \"a4\", true);\n  doc.addImage(dataURI, \"JPEG\", 5, 0, 210, 297, undefined, \"FAST\");\n  doc.save(name + \".pdf\");\n};\n"],"sourceRoot":""}